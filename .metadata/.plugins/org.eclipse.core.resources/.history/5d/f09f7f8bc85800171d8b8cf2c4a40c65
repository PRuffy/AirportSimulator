/* 
 * $Id$
 * 
 * Copyright (c) 2011-17 Stephane GALLAND <stephane.galland@utbm.fr>.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * This program is free software; you can redistribute it and/or modify
 */
package framework.gui

import framework.FrameworkLauncher
import framework.environment.EnvironmentEvent
import framework.environment.WorldModelState
import framework.math.Circle2f
import framework.math.Point2f
import framework.math.Rectangle2f
import framework.math.Shape2f
import framework.math.Vector2f
import framework.time.TimeManager
import framework.util.LocalizedString
import java.awt.BorderLayout
import java.awt.Dimension
import java.awt.Graphics2D
import java.awt.GridLayout
import java.awt.Shape
import java.awt.^event.WindowAdapter
import java.awt.^event.WindowEvent
import java.awt.geom.Ellipse2D
import java.awt.geom.GeneralPath
import java.awt.geom.Rectangle2D
import java.net.URL
import javax.swing.ImageIcon
import javax.swing.JButton
import javax.swing.JComponent
import javax.swing.JFrame
import javax.swing.JLabel
import javax.swing.JPanel
import javax.swing.JScrollPane
import javax.swing.JSlider
import javax.swing.WindowConstants

/** Abstract implementation of a GUI for the agent framework.
 *
 * @author St&eacute;phane GALLAND &lt;stephane.galland@utbm.fr&gt;
 * @version $Name$ $Revision$ $Date$
 */
abstract class AbstractFrameworkGUI extends JFrame implements FrameworkGUI {
	
	val worldWidth : float
	val worldHeight : float
	val timeManager : TimeManager
	
	var terminationHandler : ()=>void
	var environment : WorldModelStateProvider
	var lastState : WorldModelState
	
	var panel : JPanel
	/** 
	 * @param title
	 * @param worldWidth
	 * @param worldHeight
	 * @param frameIcon
	 * @param timeManager
	 */
	new(title : String, worldWidth : float, worldHeight : float, timeManager : TimeManager) {
		this.title = title
		var content = this.contentPane

		content.layout = new BorderLayout

		var world = new WorldPanel(this, isMouseCursorHidden)
		this.worldWidth = worldWidth
		this.worldHeight = worldHeight
		this.timeManager = timeManager

		this.panel = new JRootPane(world)
		content.add(BorderLayout::CENTER, panel)

		var closeBt = new JButton("Quit")
		closeBt.addActionListener [
			terminationHandler.apply
		]

		world.preferredSize = new Dimension(worldWidth as int, worldHeight as int)

		addWindowListener(new WindowClosingHandler(this))

		var mouseAdapter = new FrameworkMouseAdapter(this)
		world.addMouseMotionListener(mouseAdapter)
		world.addMouseListener(mouseAdapter)

		this.defaultCloseOperation = WindowConstants::DISPOSE_ON_CLOSE

		pack

		var d = getSize
		setLocation(-d.width / 2, -d.height / 2)
		this.locationRelativeTo = null
	}

	override environmentChanged(^event : EnvironmentEvent) {
		synchronized (treeLock) {
			if (this.environment === null) {
				this.environment = ^event.stateProvider
			}
			this.lastState = this.environment.state
			repaint
		}
	}
	
	/** Replies the last environment state.
	 * 
	 * @return the last environment state.
	 */
	override getLastWorldState : WorldModelState {
		this.lastState
	}
	
	def setTerminationHandler(handler : ()=>void) {
		this.terminationHandler = handler
	}

	def getTerminationHandler() : ()=>void {
		this.terminationHandler
	}

	/** Convert the coordinates in the MAS into the equivalent coordinates on the screen.
	 *
	 * @param p the coordinates
	 * @return the coordinates on the screen.
 	 */
	override mas2screen(p : Point2f) : Point2f {
		if (p == null) {
			return null
		}
		return new Point2f(p.x, this.worldHeight - p.y)
	}

	/** Convert the vector in the MAS into the equivalent vector on the screen.
	 *
	 * @param v the vector
	 * @return the vector on the screen.
	 */
	override mas2screen(p : Vector2f) : Vector2f {
		if (p === null) {
			return null
		}
		return new Vector2f(p.x, -p.y, true)
	}


	/** Convert the size in the MAS into the equivalent size on the screen.
	 *
	 * @param size the size
	 * @return the size on the screen.
	 */
	override mas2screen(size : float) : float {
		// No scaling/zooming
		size
	}

	/** Convert the point from the screen coordinate to the MAS coordinate.
	 *
	 * @param point the point on the screen.
	 * @return the point in the MAS
	 */
	override screen2mas(point : Point2f) : Point2f {
		if (point === null) {
			return null
		}
		return new Point2f(
				point.x,
				this.worldHeight - point.y)
	}

	/** Convert the given MAS shape to the equivalent AWT shape.
	 *
	 * @param shape the MAS shape
	 * @return the AWT shape.
	 */
	override mas2screen(shape : Shape2f<?>) : Shape {
		if (shape === null) {
			return null
		}
		if (shape instanceof Circle2f) {
			var p = shape.center.mas2screen
			var radius = shape.radius.mas2screen
			return new Ellipse2D.Float(
					p.x - radius,
					p.y - radius,
					2f * radius,
					2f * radius)
		}
		if (shape instanceof Rectangle2f) {
			var l = shape.lower.mas2screen
			var u = shape.upper.mas2screen
			return new Rectangle2D.Float(
					Math::min(l.x, u.x) as float,
					Math::min(l.y, u.y) as float,
					shape.width.mas2screen,
					shape.height.mas2screen)
		}
		throw new IllegalArgumentException
	}

	protected abstract def isMouseCursorHidden : boolean
	
	override paintWorld(g2d : Graphics2D) {
		//
	}

}
